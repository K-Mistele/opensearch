/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
const fileMap = {
  
  "analyze_knowledge_gaps.baml": "function AnalyzeKnowledgeGaps(\n    gapHistory: KnowledgeGapHistory,\n    reflection: Reflection,\n    queryPlan: string[],\n    currentRound: int\n) -> KnowledgeGapAnalysis {\n    client \"google-ai/gemini-2.5-pro\"\n    prompt #\"\n        You are an expert research strategist analyzing knowledge gaps and making decisions about research continuation.\n\n        CONTEXT:\n        - Current research round: {{currentRound}}\n        - Research has been analyzing results and may have closed some knowledge gaps\n        - You need to decide whether to continue research or generate the final answer\n        - If continuing, select which knowledge gap to focus on next\n\n        CURRENT REFLECTION RESULTS:\n        Research sufficient: {{reflection.isSufficient}}\n        Current gap closed: {{reflection.currentGapClosed}}\n        Questions answered this round: \n        {% for question in reflection.answeredQuestions %}\n            - {{question}}\n        {% endfor %}\n        - Questions still unanswered: \n        {% for question in reflection.unansweredQuestions %}\n            - {{question}}\n        {% endfor %}\n        - New gaps identified: {{reflection.newGapsIdentified}}\n\n        QUERY PLAN (Original research questions):\n        {% for index in range(queryPlan|length) %}\n        - {{index}}: {{queryPlan[index]}}\n        {% endfor %}\n\n        KNOWLEDGE GAP HISTORY:\n        {% if gapHistory.gaps|length > 0 %}\n        Previous gaps attempted:\n        {% for index in range(gapHistory.gaps|length) %}\n        Gap {{index}}:\n        - Description: {{gapHistory.gaps[index].description}}\n        - Status: {{gapHistory.gaps[index].status}}\n        - Attempt count: {{gapHistory.gaps[index].attemptCount}}\n        - Related questions from query plan: \n        {% for questionId in gapHistory.gaps[index].relatedQuestionIds %}\n            - {{queryPlan[questionId]}}\n        {% endfor %}\n        - First attempted: Round {{gapHistory.gaps[index].firstAttemptedRound}}\n        - Last attempted: Round {{gapHistory.gaps[index].lastAttemptedRound}}\n        - Previous queries tried: {{gapHistory.gaps[index].previousQueries}}\n        {% endfor %}\n\n        Current gap being researched: {% if gapHistory.currentGapIndex != -1 %}Gap {{gapHistory.currentGapIndex}}{% else %}None{% endif %}\n        {% else %}\n        This is the first research round - no gaps have been attempted yet.\n        {% endif %}\n\n        ABANDONMENT CRITERIA:\n        A knowledge gap should be marked as \"abandoned\" if ANY of these conditions are met:\n        1. **3-Round Rule**: The gap has been attempted for 3+ rounds without being resolved\n        2. **Thoroughness Assessment**: Based on the queries tried, you determine the gap has been researched thoroughly and information likely doesn't exist publicly\n        3. **Diminishing Returns**: Recent attempts show no new relevant information being found\n\n        INSTRUCTIONS:\n        1. **Analyze Current Gap Status**: \n           - If a gap was being researched this round, determine if it was closed based on reflection results\n           - Update the status of the current gap (resolved/continuing/abandoned)\n\n        2. **Process New Gaps**: \n           - If new gaps were identified in reflection, add them to the gap history\n           - Assign them to the appropriate query plan questions\n\n        3. **Abandonment Decisions**:\n           - Review all gaps and apply abandonment criteria\n           - Be conservative but realistic - don't abandon gaps too quickly\n           - Mark gaps as \"abandoned\" when appropriate with clear reasoning\n\n        4. **Next Gap Selection**:\n           - If research should continue, select the next gap to focus on\n           - Prioritize gaps addressing unanswered questions from the query plan\n           - Consider gap difficulty and likelihood of finding information\n           - Avoid gaps that have been abandoned\n\n        5. **Research Continuation Decision**:\n           - Set shouldContinueResearch to true if there are active gaps worth pursuing\n           - Set to false if all important gaps are resolved/abandoned or research is sufficient\n\n        DECISION FRAMEWORK:\n        - If reflection.isSufficient is true → shouldContinueResearch = false\n        - If all gaps are resolved or abandoned → shouldContinueResearch = false  \n        - If there are active gaps with <3 attempts → shouldContinueResearch = true\n        - If there are new gaps to investigate → shouldContinueResearch = true\n\n        Provide your analysis and decisions:\n        {{ctx.output_format}}\n    \"#\n} ",
  "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\nclient<llm> GeminiFlash25 {\n  provider google-ai\n  options {\n    model \"gemini-2.5-flash\"\n    api_key env.GOOGLE_API_KEY\n  }\n}\n\nclient<llm> GeminiPro25 {\n  provider google-ai\n  options {\n    model \"gemini-2.5-pro\"\n    api_key env.GOOGLE_API_KEY\n  }\n}\n\nclient<llm> CustomGPT4o {\n  provider openai\n  options {\n    model \"gpt-4o\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomGPT4oMini {\n  provider openai\n  retry_policy Exponential\n  options {\n    model \"gpt-4o-mini\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> CustomSonnet {\n  provider anthropic\n  options {\n    model \"claude-3-5-sonnet-20241022\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n\nclient<llm> CustomHaiku {\n  provider anthropic\n  retry_policy Constant\n  options {\n    model \"claude-3-haiku-20240307\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\nclient<llm> CustomFast {\n  provider round-robin\n  options {\n    // This will alternate between the two clients\n    strategy [CustomGPT4oMini, CustomHaiku]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\nclient<llm> OpenaiFallback {\n  provider fallback\n  options {\n    // This will try the clients in order until one succeeds\n    strategy [CustomGPT4oMini, CustomGPT4oMini]\n  }\n}\n\n// https://docs.boundaryml.com/docs/snippets/clients/retry\nretry_policy Constant {\n  max_retries 3\n  // Strategy is optional\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  // Strategy is optional\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}\n",
  "create_answer.baml": "function CreateAnswer(\n    current_date: string,\n    research_topic: string,\n    summaries: SearchResult[],\n) -> string {\n    client \"google-ai/gemini-2.5-pro\"\n    prompt #\"\n        Generate a high-quality answer formatted in markdown to the user's question based on the provided summaries.\n\n        Instructions:\n        - The current date is {{current_date}}.\n        - You are the final step of a multi-step research process, don't mention that you are the final step. \n        - You have access to all the information gathered from the previous steps.\n        - You have access to the user's question.\n        - Generate a high-quality answer to the user's question based on the provided summaries and the user's question.\n        - To include the sources you used from the Summaries in the answer correctly, use markdown footnotes. This creates a superscript number with a link to jump to the footnote. You can put footnotes anywhere in the document except inside other markdown elements like blocks, lists, and tables. \n        - When you use a footnote, you should use the id of the summary as the footnote id - the links at the bottom of the document will be added _for you_ - there is no need to add them yourself.\n        - If you use a footnote, you need to make sure that the ID of the footnote EXACTLY matches the ID of the summary.\n\n        <markdown_footnotes_example>\n            Here's a simple footnote,[^abc789a] and here's a longer one.[^90fdaha]\n\n            Note that the citations will be added for you - there is no need to add them yourself. They will be auto-generated like this:\n            [^abc789a]: This is the first footnote.\n\n            [^90fdaha]: Here's another footnote.\n\n            Here are two footnotes in a row: [^abcdefg,hijklmn]\n        </markdown_footnotes_example>\n\n        Very important instructions:\n        - if the information is not sufficient, you should indicate to the user that you don't have enough information to answer the question.\n        - make sure to indicate how confident you are in the answer, and why.\n        - Never use tables in your answer - you many use newlines, bold, italics, lists, links, and footnotes. \n\n        User Context:\n        - {{research_topic}}\n\n        Summaries:\n        <summaries>\n        {% for summary in summaries %}\n            <summary>\n                <id>{{summary.id}}</id>\n                <title>{{summary.title}}</title>                \n                <url>{{summary.url}}</url>\n                <highlights>{{summary.highlights}}</highlights>\n                <text>{{summary.text}}</text>\n            </summary>\n        {% endfor %}\n        </summaries>\n\n        Reflect carefully on all the the summaries and the user's question to provide an answer.\n        {{ctx.output_format}}\n\n    \"#\n}\n\nfunction CreateAnswerFromFacts(\n    current_date: string,\n    research_topic: string,\n    extractedFacts: ExtractedFact[],\n) -> string {\n    client \"google-ai/gemini-2.5-pro\"\n    prompt #\"\n        Generate a high-quality answer formatted in markdown to the user's question based on the provided extracted facts.\n\n        Instructions:\n        - The current date is {{current_date}}.\n        - You are the final step of a multi-step research process, don't mention that you are the final step. \n        - You have access to concise, relevant facts that have been extracted from the research process.\n        - Generate a high-quality answer to the user's question based on the provided facts and the user's question.\n        - To include the sources you used from the Facts in the answer correctly, use markdown footnotes. This creates a superscript number with a link to jump to the footnote. You can put footnotes anywhere in the document except inside other markdown elements like blocks, lists, and tables. \n        - When you use a footnote, you should use the sourceId of the fact as the footnote id - the links at the bottom of the document will be added _for you_ - there is no need to add them yourself.\n        - If you use a footnote, you need to make sure that the ID of the footnote EXACTLY matches the sourceId of the fact.\n\n        <markdown_footnotes_example>\n            Here's a simple footnote,[^abc789a] and here's a longer one.[^90fdaha]\n\n            Note that the citations will be added for you - there is no need to add them yourself. They will be auto-generated like this:\n            [^abc789a]: This is the first footnote.\n\n            [^90fdaha]: Here's another footnote.\n\n            Here are two footnotes in a row: [^abcdefg,hijklmn]\n        </markdown_footnotes_example>\n\n        Very important instructions:\n        - if the information is not sufficient, you should indicate to the user that you don't have enough information to answer the question.\n        - make sure to indicate how confident you are in the answer, and why.\n        - Never use tables in your answer - you many use newlines, bold, italics, lists, links, and footnotes. \n        - The facts provided are already concise and relevant - use them directly to build your comprehensive answer.\n\n        User Context:\n        - {{research_topic}}\n\n        Extracted Facts:\n        <facts>\n        {% for fact in extractedFacts %}\n            <factSet>\n                <sourceId>{{fact.sourceId}}</sourceId>\n                <summary>{{fact.summary}}</summary>\n                <relevantFacts>\n                    {% for relevantFact in fact.relevantFacts %}\n                    - {{relevantFact}}\n                    {% endfor %}\n                </relevantFacts>\n            </factSet>\n        {% endfor %}\n        </facts>\n\n        Reflect carefully on all the extracted facts and the user's question to provide a comprehensive answer.\n        {{ctx.output_format}}\n\n    \"#\n}\n",
  "extract_facts.baml": "function ExtractRelevantFacts(\n    relevantSources: SearchResult[],\n    research_topic: string,\n    queryPlan: string[],\n    reflection: Reflection,\n    current_date: string\n) -> ExtractedFact[] {\n    client \"google-ai/gemini-2.5-flash\"\n    prompt #\"\n    You are an expert research assistant extracting key facts from sources to answer research questions about \"{{research_topic}}\".\n\n    The current date is {{current_date}}.\n\n    CONTEXT:\n    The following sources have been identified as containing relevant information for this research topic. Your task is to extract only the most important facts from each source that directly relate to answering the research questions.\n\n    Query Plan (Research Questions to Address):\n    {% for index in range(queryPlan|length) %}\n    - {{index}}: {{queryPlan[index]}}\n    {% endfor %}\n\n    {% if reflection.knowledgeGap %}\n    Knowledge Gap Analysis:\n    Current Knowledge Gap: {{reflection.knowledgeGap}}\n    {% endif %}\n\n    INSTRUCTIONS:\n    - For each source, extract ONLY the facts that are directly relevant to answering the research questions in the query plan\n    - Each fact should be at maximum 2-3 sentences and contain specific, concrete information or context that is relevant to the research questions\n    - Extract only what's necessary - if a source only has 1 relevant fact, extract 1 fact (don't force more)\n    - Maximum 5 facts per source, but extract fewer if that's all that's relevant\n    - Focus on concrete details: numbers, dates, specific claims, evidence, etc.\n    - Avoid general statements or background information unless directly relevant to the research questions\n    - Each fact should be self-contained and understandable on its own\n    - Preserve the essence of the information while making it concise\n    - do not duplicate facts from other sources - if a fact is already extracted from another source, do not extract it again\n    - IMPORTANT: Make sure the sourceId you provide EXACTLY matches the id of the source you're extracting from\n\n    RELEVANCE CRITERIA:\n    - The fact must help answer at least one question from the query plan\n    - The fact must contain specific, actionable information (not just context)\n    - The fact must be unique and not duplicate information from other sources\n\n    SOURCE FORMAT:\n    For each source, provide:\n    1. The sourceId (must exactly match the source's id)\n    2. A brief summary of the source / why the source is relevant to the research topic\n    3. The extracted facts that answer the research questions\n\n    Sources to Process:\n    <sources>\n    {% for source in relevantSources %}\n        <source>\n            <id>{{source.id}}</id>\n            <title>{{source.title}}</title>\n            <url>{{source.url}}</url>\n            <highlights>{{source.highlights}}</highlights>\n            <text>{{source.text}}</text>\n        </source>\n    {% endfor %}\n    </sources>\n\n    Extract the relevant facts following this format:\n    {{ctx.output_format}}\n    \"#\n} ",
  "generate_followup_queries.baml": "function GenerateFollowUpQueries(\n    targetGap: string,\n    previousQueries: string[],\n    reflection: Reflection,\n    queryPlan: string[],\n    currentRound: int,\n    unansweredQuestions: int[]\n) -> FollowUpQueryGeneration {\n    client \"google-ai/gemini-2.5-flash\"\n    prompt #\"\n        You are an expert search query strategist generating diverse follow-up queries to address a specific knowledge gap.\n\n        CONTEXT:\n        - Current research round: {{currentRound}}\n        - You need to generate queries that will help close a specific knowledge gap\n        - You must ensure query diversity and avoid repeating previous failed attempts\n\n        TARGET KNOWLEDGE GAP:\n        {{targetGap}}\n\n        QUERY PLAN CONTEXT:\n        {% for index in range(queryPlan|length) %}\n        - {{index}}: {{queryPlan[index]}}\n        {% endfor %}\n\n        PREVIOUS QUERIES ATTEMPTED FOR THIS GAP:\n        {% if previousQueries|length > 0 %}\n        {% for query in previousQueries %}\n        - \"{{query}}\"\n        {% endfor %}\n        {% else %}\n        No previous queries have been attempted for this specific gap.\n        {% endif %}\n\n        REFLECTION INSIGHTS:\n        Questions answered this round: \n        {% for question in reflection.answeredQuestions %}\n        - {{question}}\n        {% endfor %}\n        Questions still unanswered: \n        {% for question in unansweredQuestions %}\n        - {{question}}: {{queryPlan[question]}}\n        {% endfor %}\n        Current gap closed: {{reflection.currentGapClosed}}\n        Relevant sources found: \n        {% for source in reflection.relevantSummaryIds %}\n        - {{source}}\n        {% endfor %}\n\n        QUERY DIVERSITY STRATEGIES:\n        You MUST ensure the new queries are diverse and different from previous attempts. Apply these strategies:\n\n        1. **Keyword Variation**: Use different terminology, synonyms, and industry-specific terms\n        2. **Search Angles**: Approach the topic from different perspectives (company, industry, investor, regulatory, news)\n        3. **Specificity Levels**: Mix broad context queries with highly specific targeted searches\n        4. **Temporal Focus**: Try different time periods (recent, historical, specific years/quarters)\n        5. **Source Types**: Target different types of sources (news, reports, filings, interviews, databases)\n        6. **Geographic Scope**: Consider different geographic markets or regions if relevant\n\n        QUERY GENERATION RULES:\n        - Generate 2-4 queries maximum (focus on quality over quantity)\n        - Each query should target the specific knowledge gap from a different angle\n        - Avoid repeating any previous query patterns or keywords\n        - Ensure queries are suitable for Exa Search API (no Google-specific operators)\n        - Make queries specific enough to find targeted information\n        - Include important qualifiers and modifiers for precision\n\n        EXAMPLE DIVERSITY APPROACHES:\n        If previous queries focused on \"company funding\", try:\n        - \"venture capital investment [company]\"\n        - \"[company] Series A B C funding rounds\"  \n        - \"[company] investor relations financial backing\"\n        - \"[company] startup financing valuation\"\n\n        CRITICAL REQUIREMENT:\n        Analyze the previous queries carefully and ensure your new queries use:\n        - Completely different keywords and phrases\n        - Different search approaches and angles\n        - Alternative ways to describe the same information need\n\n        Generate your diverse follow-up queries and explain your strategy:\n        {{ctx.output_format}}\n    \"#\n} ",
  "generate_query.baml": "/// Generate an optimized query (or several) for web research\nfunction GenerateQuery(\n    args: GenerateQueryArgs,\n) -> SearchQueryList {\n    client \"google-ai/gemini-2.5-flash\"\n    prompt #\"\n    \n        {{ _.role(\"system\")}}\n        Your goal is to generate sophisticated and diverse web search queries AND create a comprehensive query plan. These queries are intended for an advanced automated web research tool capable of analyzing complex results, following links, and synthesizing information.\n\n        Instructions for Search Queries:\n        - Always prefer a single search query, only add another query if the original question requests multiple aspects or elements and one query is not enough.\n        - Each query should focus on one specific aspect of the original question.\n\n        {% if args.number_queries == 1 %}\n        - Generate 1 query.\n        {% elif args.number_queries %}\n        - Don't produce less than 2 queries.\n        - Don't produce more than {{args.number_queries}} queries.\n        {% else %}\n        - Generate a few queries\n        {% endif %}\n        - Queries should be diverse, if the topic is broad, generate more than 1 query to get sufficient coverage of different keywords and assumptions.\n        - Don't generate multiple similar queries, 1 is enough.\n        - Queries should be specific and not too broad. Make sure to include important qualifiers and modifiers.\n        - Query should ensure that the most current information is gathered. The current date is {{args.current_date}}.\n        - We are using Exa's Search API so the queries should not use google-specific search operators\n        - If the query is complicated or multi-part (e.g. about multiple different people, businesses, entities or topics), break it down into multiple queries.\n\n        Instructions for Query Plan:\n        - Create a comprehensive list of specific questions that need to be answered to fully satisfy the user's research topic by deconstructing the research topic into smaller, more specific questions\n        - These questions should be detailed and specific, covering all aspects of the research topic\n        - Questions should not include information which you already know the answer to, such as common knowledge.\n        - The questions should be answerable through web research and should guide the evaluation of whether research is complete\n        - Think about what a complete answer to the research topic would need to include, then break that down into specific questions\n        - Questions should be comprehensive enough that if all are answered, the research topic is fully addressed\n        - They should follow the SMART: Specific, Measurable, Achievable, and Relevant criteria.\n\n        The research topic is provided between <research_topic></research_topic> XML tags below.\n        <research_topic>\n        {{ args.research_topic}}\n        </research_topic>\n\n        <output_format>\n        {{ ctx.output_format }}\n        </output_format>\n    \"#\n}\n\n",
  "generate_query.test.baml": "test NapthaAiFunding {\n    functions [GenerateQuery]\n    args {\n        args {\n            research_topic \"What is Naptha AI's most recent funding round in terms of dollars raised and the round size? (pre-seed, seed,Series A, Series B, Series C, Series D)\"\n            current_date \"06/24/2025\"\n        }\n\n    }\n}\n\ntest ConstellateAIFunding {\n    functions [GenerateQuery]\n    args {\n       args {\n            research_topic \"What is Constellate AI's most recent funding round in terms of dollars raised and the round size? (pre-seed, seed,Series A, Series B, Series C, Series D)\"\n            number_queries 10\n            current_date: \"06/24/2025\"\n       }\n    }\n}\n\ntest HumanLayerFunding {\n    functions [GenerateQuery]\n    args {\n        args {\n            research_topic \"What is Human Layer's most recent funding round in terms of dollars raised and the round size? (pre-seed, seed,Series A, Series B, Series C, Series D)\"\n            number_queries 10\n            current_date: \"06/24/2025\"\n        }\n    }\n}   \n\ntest BoundaryMLFunding {\n    functions [GenerateQuery]\n    args {\n        args {\n            research_topic \"What is BoundaryML's most recent funding round in terms of dollars raised and the round size? (pre-seed, seed,Series A, Series B, Series C, Series D)\"\n            number_queries 10\n            current_date: \"06/24/2025\"\n        }\n    }\n}",
  "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"typescript\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.90.2\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode async\n}\n",
  "reflect.baml": "// Gap closure focused reflection function\nfunction Reflect(\n    summaries: SearchResult[],\n    research_topic: string,\n    current_date: string,\n    queryPlan: string[],\n    completedQuestions: int[],\n    unansweredQuestions: int[],\n    currentGap: string?,\n    currentRound: int,\n    maxRounds: int,\n) -> Reflection {\n    client \"google-ai/gemini-2.5-flash\"\n    prompt #\"\n    You are an expert research analyst focused on gap closure assessment for \"{{research_topic}}\".\n\n    The current date is {{current_date}}.\n    \n    Research Progress: This is round {{currentRound}} of {{maxRounds}} maximum rounds.\n\n    CURRENT KNOWLEDGE GAP BEING RESEARCHED:\n    {% if currentGap %}\n    \"{{currentGap}}\"\n    {% else %}\n    No specific gap was being researched this round (initial research phase).\n    {% endif %}\n\n    Query Plan:\n    The following questions were previously identified as needing to be answered:\n    {% for index in range(queryPlan|length) %}\n    - {{index}} [{% if index in completedQuestions %}Answered{% else %}Unanswered{% endif %}] {{queryPlan[index]}}\n    {% endfor %}\n\n    PRIMARY FOCUS - GAP CLOSURE ASSESSMENT:\n    Your main task is to determine if the knowledge gap we were trying to close this round was successfully closed.\n\n    {% if currentGap %}\n    SPECIFIC INSTRUCTIONS FOR CURRENT GAP:\n    1. **Gap Closure Analysis**: Did the search results this round provide information that closes the knowledge gap \"{{currentGap}}\"?\n    2. **Evidence Evaluation**: Do the summaries contain concrete, specific information that addresses this gap?\n    3. **Gap Status**: Mark currentGapClosed as true only if the gap has been definitively addressed with specific evidence\n    {% else %}\n    INITIAL ROUND INSTRUCTIONS:\n    1. **Question Progress**: Analyze which questions from the query plan were answered by this round's results\n    2. **Gap Identification**: Identify what knowledge gaps exist based on unanswered questions\n    3. **New Gap Discovery**: List any new gaps discovered during analysis\n    {% endif %}\n\n    SECONDARY TASKS:\n    1. **Question Tracking**: Update which questions from the query plan have been answered this round\n    2. **Source Identification**: Identify which summaries contain relevant information\n    3. **Overall Sufficiency**: Determine if research overall is sufficient to answer the research topic\n    4. **New Gap Identification**: Identify any new knowledge gaps discovered in the analysis\n\n    IMPORTANT OUTPUT REQUIREMENTS:\n    - **answeredQuestions**: Return ONLY the question indices (0-based) that were answered THIS ROUND by the current search results\n    - **unansweredQuestions**: This field is not used - the system tracks this externally\n    - Focus on identifying which questions from the query plan got new answers from this round's search results\n    - Do NOT try to maintain cumulative state - only report new answers from this specific round\n\n    ANALYSIS CRITERIA:\n    - Be conservative about gap closure - require concrete evidence\n    - A gap is only closed if you found specific, detailed information addressing it\n    - Mark questions as answered only if they have comprehensive answers with evidence\n    - Identify sources that provide unique, relevant information for extraction\n\n    Current Round's Search Results:\n    <summaries>\n    {% for summary in summaries %}\n        <summary>\n            <title>{{summary.title}}</title>\n            <url>{{summary.url}}</url>\n            <highlights>{{summary.highlights}}</highlights>\n            <id>{{summary.id}}</id>\n            <text>{{summary.text}}</text>\n        </summary>\n    {% endfor %}\n    </summaries>\n\n    Provide your gap closure assessment and analysis:\n    {{ctx.output_format}}\n    \"#\n}",
  "types.baml": "class GenerateQueryArgs {\n    research_topic string\n    current_date string\n    number_queries int?\n}\n// State management types for the research workflow\nclass SearchQueryList {\n    queryPlan string[] @description(\"A list of specific questions that need to be answered to satisfy the user's research topic. These questions will be used to determine if the research is complete.\")\n    query string[] @description(\"A list of search queries to be used for web research.\")\n    rationale string @description(\"A brief explanation of why these queries are relevant to the research topic, addressed as though you were speaking to a user explaining what you are doing\")\n}\n\nclass Reflection {\n    isSufficient bool @description(\"Whether research is complete overall\")\n    answeredQuestions int[] @description(\"Cumulative list of query plan question indices that have been answered across all rounds so far\")\n    unansweredQuestions int[] @description(\"Cumulative list of query plan question indices that remain unanswered across all rounds so far\")\n    relevantSummaryIds string[] @description(\"Sources with relevant information\")\n    currentGapClosed bool @description(\"Whether the knowledge gap we were trying to close this round was successfully closed\")\n    newGapsIdentified string[]? @description(\"Any new knowledge gaps discovered this round\")\n}\n\nclass Message {\n    role string @description(\"The role of the message sender (e.g., 'user', 'assistant', 'system')\")\n    content string @description(\"The content of the message\")\n}\n\nclass ReflectionState {\n    is_sufficient bool @description(\"Whether the current information is sufficient\")\n    knowledge_gap string @description(\"Description of the knowledge gap identified\")\n    follow_up_queries string[] @description(\"Follow-up queries to address knowledge gaps\")\n    research_loop_count int @description(\"Current research loop count\")\n    number_of_ran_queries int @description(\"Number of queries that have been executed\")\n}\n\nclass Query {\n    query string @description(\"The search query string\")\n    rationale string @description(\"Rationale for why this query is needed\")\n}\n\nclass QueryGenerationState {\n    search_query Query[] @description(\"List of generated queries with rationales\")\n}\n\nclass WebSearchState {\n    search_query string @description(\"The search query to execute\")\n    id string @description(\"Unique identifier for the search\")\n}\n\nclass SearchStateOutput {\n    running_summary string? @description(\"Final report or running summary of research\")\n} \n\nclass SearchResult {\n    url string @description(\"The URL of the search result\")\n    id string @description(\"The ID of the search result\")\n    title string? | null @description(\"The title of the search result\")\n    highlights string[] @description(\"The highlights of the search result\")\n    highlightScores float[] @description(\"The highlight scores of the search result\")\n    text string @description(\"The text of the search result\")\n}\n\nclass ExtractedFact {\n    sourceId string @description(\"ID matching the original Search Result for citation purposes\")\n    relevantFacts string[] @description(\"Array of concise facts relevant to the query plan (max 5 facts, 2-3 sentences each, only extract what's necessary)\")\n    summary string @description(\"Brief summary of the source's relevance to the research topic\")\n}\n\n// Knowledge Gap History Tracking Types\nclass AttemptedKnowledgeGap {\n    description string @description(\"Description of the knowledge gap\")\n    attemptCount int @description(\"Number of rounds spent trying to solve this gap\")\n    status \"active\" | \"abandoned\" | \"resolved\" @description(\"Current status of this knowledge gap\")\n    previousQueries string[] @description(\"All queries previously tried for this gap\")\n    relatedQuestionIds int[] @description(\"Query plan question IDs this gap addresses\")\n    firstAttemptedRound int @description(\"Round when this gap was first identified\")\n    lastAttemptedRound int @description(\"Most recent round when this gap was attempted\")\n}\n\nclass KnowledgeGapHistory {\n    gaps AttemptedKnowledgeGap[] @description(\"History of all knowledge gaps attempted\")\n    currentGapIndex int? @description(\"Index of the currently active knowledge gap (-1 if none)\")\n}\n\n\n\n// Knowledge Gap Analysis types\nclass KnowledgeGapAnalysis {\n    shouldContinueResearch bool @description(\"Whether to continue research or generate final answer\")\n    nextGapToResearch string? @description(\"Description of the next knowledge gap to focus on\")\n    gapStatus \"new\" | \"continuing\" | \"switching\" | \"complete\" @description(\"What we're doing with knowledge gaps\")\n    reasoning string @description(\"Explanation of the decision\")\n    updatedGapHistory AttemptedKnowledgeGap[] @description(\"Updated status of all attempted gaps\")\n}\n\nclass FollowUpQueryGeneration {\n    queries string[] @description(\"Follow-up search queries for the current knowledge gap\")\n    rationale string @description(\"Explanation of why these queries will help close the gap\")\n    queryStrategy string @description(\"Strategy used to ensure query diversity\")\n}",
}
export const getBamlFiles = () => {
    return fileMap;
}